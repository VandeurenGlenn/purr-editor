<link rel="import" href="../mixins/local-storage-map-mixin.html">

<template id="ace-window">
  <style>
    ::slotted(.ace) {
      flex: 1;
    }
    :host([hidden]) ::slotted(.ace) {
      opacity: 0;
      pointer-events: none;
    }
    ::slotted(.ace_tooltip) {
      background: red
    }
  </style>
  <slot></slot>
</template>

<script>
  Backed(class AceWindow extends window.LocalStorageMapMixin(HTMLElement) {
    // TODO: init ace outside AceWindow
    static get properties() {
      return {

        loadedMap: {
          value: new Map()
        },

        lib: {
          value: 'bower_components/ace-builds/src-min-noconflict/'
        },

        ace: {
          observer: 'render'
        },

        theme: {
          value: 'github',
          observer: 'render'
        },

        mode: {
          observer: 'render'
        },

        contents: {
          observer: 'render'
        },

        autoSave: {
          value: true
        },

        autoSaveTimeout: {
          value: 1000
        },

        config: {
          value: null,
          observer: '__configObserver__'
        }
      }
    }

    get editor() {
      if (!this.__editor)
        this.__editor = document.createElement('div');
        this.__editor.classList.add('ace');
      return this.__editor;
    }

    created() {
      this.__contentsChanged__ = this.__contentsChanged__.bind(this)
      this.onKeyDown = this.onKeyDown.bind(this)
      this.localNS = 'purr-editor-settings::general';
      this.config = this.localGet();
    }

    ready() {
      this.ace = ace.edit(this.editor);
      this.ace.setOptions({
          enableBasicAutocompletion: this.basicAutocompletion,
          enableSnippets: this.snippets,
          enableLiveAutocompletion: {
            set: val => {
              if (val) {
                // Trigger the autocomplete on each change
                this.editor.commands.on('afterExec', this.doLiveAutocomplete);
              } else {
                this.editor.commands.removeListener('afterExec', this.doLiveAutocomplete);
              }
            },
            value: this.liveAutocompletion
          }
      });
      this.ace.addEventListener('change', this.__contentsChanged__);
      this.appendChild(this.editor);
      this.addEventListener('keydown', this.onKeyDown);
    }

    disconnected() {
      this.removeEventListener('keydown', this.onKeyDown);
    }

    onKeyDown(event) {
      const { key, ctrlKey} = event;
      if (ctrlKey && key === 's') {
        event.preventDefault();
        if (!this.autoSave) {
          // this.save().then(() => {
            this.shouldSave = false;
            document.dispatchEvent(new CustomEvent('ace-window-contents-change', {detail: {
              key: this.dataset.uid,
              contents: this.ace.getValue(),
              reason: 'save'
            }}))
          // });
        }
      }
    }

    __configObserver__(change) {
      if (change.value) {
        for (const entry of change.value.entries()) {
          this[entry[0]] = entry[1];
        }
      }
    }

    __setupAce() {
      this.ace = ace.edit(this.editor);
      this.ace.addEventListener('change', this.__contentsChanged__);
    }

    render(change) {
      if (this.ace && this.mode && this.theme && this.contents) {
        const contents = this.contents;
        this.setTheme(this.theme);
        this.setMode(this.mode);
        this.ace.setValue(contents === '__purr__editor' ? '' : contents);
      }
    }

    __contentsChanged__(change) {
      if (typeof change === 'object') {
        if (this.autoSave) {
          // TODO: track changes for undoing
          // timeout so we don't stress the browser so much
          if (this.saveTimeoutRunning) {
            clearTimeout(this.saveTimeout);
            this.saveTimeoutRunning = false;
          }
          this.saveTimeoutRunning = true;
          this.saveTimeout = setTimeout(() => {
            this.save();
          }, this.autoSaveTimeout);
        } else {
          this.shouldSave = true;
          document.dispatchEvent(new CustomEvent('ace-window-contents-change', {detail: {
            key: this.dataset.uid
          }}))
          // this.save();
        }
      }
    }

    save() {
      return new Promise((resolve, reject) => {
        const project = new Map(JSON.parse(localStorage.getItem('purr-editor::project')));
        const file = project.get(this.dataset.uid);
        file.contents = this.ace.getValue();
        project.set(this.dataset.uid, file);
        localStorage.setItem('purr-editor::project', JSON.stringify(Array.from(project)));
        resolve();
      });
    }

    needsLoad(key) {
      return this.loadedMap.has(key)
    }

    setTheme(theme) {
      if (this.needsLoad(theme)) {
        this.loadScript(this.lib + 'theme-' + theme + '.js').then(() => {
          this.ace.setTheme('ace/theme/' + theme);
        });
      } else {
        this.ace.setTheme('ace/theme/' + theme);
      }

    }

    setMode(mode) {
      if (this.needsLoad(mode)) {
        // load mode
        this.loadScript(this.lib + 'mode-' + mode + '.js').then(() => {
          this.ace.getSession().setMode('ace/mode/' + mode);
          this.loadedMap.set(mode, true);
        });
      } else {
        this.ace.getSession().setMode('ace/mode/' + mode);
      }
    }

    getCompletionPrefix(editor) {
      var pos = editor.getCursorPosition();
      var line = editor.session.getLine(pos.row);
      var prefix = util.retrievePrecedingIdentifier(line, pos.column);
      // Try to find custom prefixes on the completers
      editor.completers.forEach(function(completer) {
        if (completer.identifierRegexps) {
          completer.identifierRegexps.forEach(function(identifierRegex) {
            if (!prefix && identifierRegex)
              prefix = util.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
          });
        }
      });
      return prefix;
    }

    doLiveAutocomplete(e) {
      var editor = e.editor;
      var text = e.args || "";
      var hasCompleter = editor.completer && editor.completer.activated;

      // We don't want to autocomplete with no prefix
      if (e.command.name === "backspace") {
        if (hasCompleter && !getCompletionPrefix(editor))
            editor.completer.detach();
      }
      else if (e.command.name === "insertstring") {
        var prefix = getCompletionPrefix(editor);
        // Only autocomplete if there's a prefix that can be matched
        if (prefix && !hasCompleter) {
            if (!editor.completer) {
                // Create new autocompleter
                editor.completer = new Autocomplete();
            }
            // Disable autoInsert
            editor.completer.autoSelect = false;
            editor.completer.autoInsert = false;
            editor.completer.showPopup(editor);
        } else if (!prefix && hasCompleter) {
            // When the prefix is empty
            // close the autocomplete dialog
            editor.completer.detach();
        }
      }
    }
  });
</script>
